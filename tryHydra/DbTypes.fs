// This code was generated by `SqlHydra.Npgsql` -- v2.5.0.
namespace Games.DbTypes

open SqlHydra
open SqlHydra.Query.Table

[<AutoOpen>]
module ColumnReaders =
    type Column(reader: System.Data.IDataReader, getOrdinal: string -> int, column) =
            member __.Name = column
            member __.IsNull() = getOrdinal column |> reader.IsDBNull
            override __.ToString() = __.Name

    type RequiredColumn<'T, 'Reader when 'Reader :> System.Data.IDataReader>(reader: 'Reader, getOrdinal, getter: int -> 'T, column) =
            inherit Column(reader, getOrdinal, column)
            member __.Read(?alias) = alias |> Option.defaultValue __.Name |> getOrdinal |> getter

    type OptionColumn<'T, 'Reader when 'Reader :> System.Data.IDataReader>(reader: 'Reader, getOrdinal, getter: int -> 'T, column) =
            inherit Column(reader, getOrdinal, column)
            member __.Read(?alias) = 
                match alias |> Option.defaultValue __.Name |> getOrdinal with
                | o when reader.IsDBNull o -> None
                | o -> Some (getter o)

    type NullableObjectColumn<'T, 'Reader when 'Reader :> System.Data.IDataReader>(reader: 'Reader, getOrdinal, getter: int -> 'T, column) =
            inherit Column(reader, getOrdinal, column)
            member __.Read(?alias) = 
                match alias |> Option.defaultValue __.Name |> getOrdinal with
                | o when reader.IsDBNull o -> null
                | o -> (getter o) |> unbox

    type NullableValueColumn<'T, 'Reader when 'T : struct and 'T : (new : unit -> 'T) and 'T :> System.ValueType and 'Reader :> System.Data.IDataReader>(reader: 'Reader, getOrdinal, getter: int -> 'T, column) =
            inherit Column(reader, getOrdinal, column)
            member __.Read(?alias) = 
                match alias |> Option.defaultValue __.Name |> getOrdinal with
                | o when reader.IsDBNull o -> System.Nullable<'T>()
                | o -> System.Nullable<'T> (getter o)

[<AutoOpen>]
module private DataReaderExtensions =
    type System.Data.IDataReader with
        member reader.GetDateOnly(ordinal: int) = 
            reader.GetDateTime(ordinal) |> System.DateOnly.FromDateTime
    
    type System.Data.Common.DbDataReader with
        member reader.GetTimeOnly(ordinal: int) = 
            reader.GetFieldValue(ordinal) |> System.TimeOnly.FromTimeSpan
        

module games =
    type rating =
        | super = 1
        | good = 2
        | ok = 3
        | meh = 4
        | monopoly = 5

    [<CLIMutable>]
    type games =
        { [<ProviderDbType("Integer")>]
          id: int
          [<ProviderDbType("Varchar")>]
          name: string
          [<ProviderDbType("Integer")>]
          year: Option<int> }

    let games = table<games>

    [<CLIMutable>]
    type games_with_info =
        { [<ProviderDbType("Varchar")>]
          name: Option<string>
          [<ProviderDbType("Numeric")>]
          geek_rating: Option<decimal>
          [<ProviderDbType("Varchar")>]
          owner_name: Option<string> }

    let games_with_info = table<games_with_info>

    [<CLIMutable>]
    type ratings =
        { [<ProviderDbType("Integer")>]
          id: int
          [<ProviderDbType("Integer")>]
          game_id: int
          [<ProviderDbType("Numeric")>]
          geek_rating: decimal
          [<ProviderDbType("Date")>]
          date: Option<System.DateOnly>
          my_rating: rating }

    let ratings = table<ratings>

    module Readers =
        type gamesReader(reader: Npgsql.NpgsqlDataReader, getOrdinal) =
            member __.id = RequiredColumn(reader, getOrdinal, reader.GetInt32, "id")
            member __.name = RequiredColumn(reader, getOrdinal, reader.GetString, "name")
            member __.year = OptionColumn(reader, getOrdinal, reader.GetInt32, "year")

            member __.Read() =
                { id = __.id.Read()
                  name = __.name.Read()
                  year = __.year.Read() }
                : games

            member __.ReadIfNotNull() =
                if __.id.IsNull() then None else Some(__.Read())

        type games_with_infoReader(reader: Npgsql.NpgsqlDataReader, getOrdinal) =
            member __.name = OptionColumn(reader, getOrdinal, reader.GetString, "name")
            member __.geek_rating = OptionColumn(reader, getOrdinal, reader.GetDecimal, "geek_rating")
            member __.owner_name = OptionColumn(reader, getOrdinal, reader.GetString, "owner_name")

            member __.Read() =
                { name = __.name.Read()
                  geek_rating = __.geek_rating.Read()
                  owner_name = __.owner_name.Read() }
                : games_with_info

            member __.ReadIfNotNull() =
                if __.name.IsNull() then None else Some(__.Read())

        type ratingsReader(reader: Npgsql.NpgsqlDataReader, getOrdinal) =
            member __.id = RequiredColumn(reader, getOrdinal, reader.GetInt32, "id")
            member __.game_id = RequiredColumn(reader, getOrdinal, reader.GetInt32, "game_id")
            member __.geek_rating = RequiredColumn(reader, getOrdinal, reader.GetDecimal, "geek_rating")
            member __.date = OptionColumn(reader, getOrdinal, reader.GetDateOnly, "date")
            member __.my_rating = RequiredColumn(reader, getOrdinal, reader.GetFieldValue, "my_rating")

            member __.Read() =
                { id = __.id.Read()
                  game_id = __.game_id.Read()
                  geek_rating = __.geek_rating.Read()
                  date = __.date.Read()
                  my_rating = __.my_rating.Read() }
                : ratings

            member __.ReadIfNotNull() =
                if __.id.IsNull() then None else Some(__.Read())

module people =
    [<CLIMutable>]
    type friends =
        { [<ProviderDbType("Integer")>]
          id: int
          [<ProviderDbType("Varchar")>]
          name: string
          [<ProviderDbType("Integer")>]
          age: Option<int> }

    let friends = table<friends>

    [<CLIMutable>]
    type game_owners =
        { [<ProviderDbType("Integer")>]
          id: int
          [<ProviderDbType("Integer")>]
          owner_id: int
          [<ProviderDbType("Integer")>]
          game_id: int }

    let game_owners = table<game_owners>

    module Readers =
        type friendsReader(reader: Npgsql.NpgsqlDataReader, getOrdinal) =
            member __.id = RequiredColumn(reader, getOrdinal, reader.GetInt32, "id")
            member __.name = RequiredColumn(reader, getOrdinal, reader.GetString, "name")
            member __.age = OptionColumn(reader, getOrdinal, reader.GetInt32, "age")

            member __.Read() =
                { id = __.id.Read()
                  name = __.name.Read()
                  age = __.age.Read() }
                : friends

            member __.ReadIfNotNull() =
                if __.id.IsNull() then None else Some(__.Read())

        type game_ownersReader(reader: Npgsql.NpgsqlDataReader, getOrdinal) =
            member __.id = RequiredColumn(reader, getOrdinal, reader.GetInt32, "id")
            member __.owner_id = RequiredColumn(reader, getOrdinal, reader.GetInt32, "owner_id")
            member __.game_id = RequiredColumn(reader, getOrdinal, reader.GetInt32, "game_id")

            member __.Read() =
                { id = __.id.Read()
                  owner_id = __.owner_id.Read()
                  game_id = __.game_id.Read() }
                : game_owners

            member __.ReadIfNotNull() =
                if __.id.IsNull() then None else Some(__.Read())

type HydraReader(reader: Npgsql.NpgsqlDataReader) =
    let mutable accFieldCount = 0
    let buildGetOrdinal tableType =
        let fieldNames = 
            FSharp.Reflection.FSharpType.GetRecordFields(tableType)
            |> Array.map _.Name

        let dictionary = 
            [| 0 .. reader.FieldCount - 1 |] 
            |> Array.map (fun i -> reader.GetName(i), i)
            |> Array.sortBy snd
            |> Array.skip accFieldCount
            |> Array.filter (fun (name, _) -> Array.contains name fieldNames)
            |> Array.take fieldNames.Length
            |> dict
        accFieldCount <- accFieldCount + fieldNames.Length
        fun col -> dictionary.Item col
        
    let lazygamesgames = lazy (games.Readers.gamesReader(reader, buildGetOrdinal typeof<games.games>))
    let lazygamesgames_with_info = lazy (games.Readers.games_with_infoReader(reader, buildGetOrdinal typeof<games.games_with_info>))
    let lazygamesratings = lazy (games.Readers.ratingsReader(reader, buildGetOrdinal typeof<games.ratings>))
    let lazypeoplefriends = lazy (people.Readers.friendsReader(reader, buildGetOrdinal typeof<people.friends>))
    let lazypeoplegame_owners = lazy (people.Readers.game_ownersReader(reader, buildGetOrdinal typeof<people.game_owners>))
    member __.``games.games`` = lazygamesgames.Value
    member __.``games.games_with_info`` = lazygamesgames_with_info.Value
    member __.``games.ratings`` = lazygamesratings.Value
    member __.``people.friends`` = lazypeoplefriends.Value
    member __.``people.game_owners`` = lazypeoplegame_owners.Value
    member private __.AccFieldCount with get () = accFieldCount and set (value) = accFieldCount <- value

    member private __.GetReaderByName(entity: string, isOption: bool) =
        match entity, isOption with
        | "games.games", false -> __.``games.games``.Read >> box
        | "games.games", true -> __.``games.games``.ReadIfNotNull >> box
        | "games.games_with_info", false -> __.``games.games_with_info``.Read >> box
        | "games.games_with_info", true -> __.``games.games_with_info``.ReadIfNotNull >> box
        | "games.ratings", false -> __.``games.ratings``.Read >> box
        | "games.ratings", true -> __.``games.ratings``.ReadIfNotNull >> box
        | "people.friends", false -> __.``people.friends``.Read >> box
        | "people.friends", true -> __.``people.friends``.ReadIfNotNull >> box
        | "people.game_owners", false -> __.``people.game_owners``.Read >> box
        | "people.game_owners", true -> __.``people.game_owners``.ReadIfNotNull >> box
        | _ -> failwith $"Could not read type '{entity}' because no generated reader exists."

    static member private GetPrimitiveReader(t: System.Type, reader: Npgsql.NpgsqlDataReader, isOpt: bool, isNullable: bool) =
        let wrapValue get (ord: int) = 
            if isOpt then (if reader.IsDBNull ord then None else get ord |> Some) |> box 
            elif isNullable then (if reader.IsDBNull ord then System.Nullable() else get ord |> System.Nullable) |> box
            else get ord |> box

        let wrapRef get (ord: int) = 
            if isOpt then (if reader.IsDBNull ord then None else get ord |> Some) |> box 
            else get ord |> box
        
        if t = typedefof<bool> then Some(wrapValue reader.GetBoolean)
        elif t = typedefof<bool[]> then Some(wrapRef reader.GetFieldValue<bool[]>)
        elif t = typedefof<int16> then Some(wrapValue reader.GetInt16)
        elif t = typedefof<int16[]> then Some(wrapRef reader.GetFieldValue<int16[]>)
        elif t = typedefof<int> then Some(wrapValue reader.GetInt32)
        elif t = typedefof<int[]> then Some(wrapRef reader.GetFieldValue<int[]>)
        elif t = typedefof<int64> then Some(wrapValue reader.GetInt64)
        elif t = typedefof<int64[]> then Some(wrapRef reader.GetFieldValue<int64[]>)
        elif t = typedefof<double> then Some(wrapValue reader.GetDouble)
        elif t = typedefof<double[]> then Some(wrapRef reader.GetFieldValue<double[]>)
        elif t = typedefof<decimal> then Some(wrapValue reader.GetDecimal)
        elif t = typedefof<decimal[]> then Some(wrapRef reader.GetFieldValue<decimal[]>)
        elif t = typedefof<string> then Some(wrapRef reader.GetString)
        elif t = typedefof<string[]> then Some(wrapRef reader.GetFieldValue<string[]>)
        elif t = typedefof<System.Guid> then Some(wrapValue reader.GetGuid)
        elif t = typedefof<System.Guid[]> then Some(wrapRef reader.GetFieldValue<System.Guid[]>)
        elif t = typedefof<System.TimeSpan> then Some(wrapRef reader.GetTimeSpan)
        elif t = typedefof<System.TimeSpan[]> then Some(wrapRef reader.GetFieldValue<System.TimeSpan[]>)
        elif t = typedefof<System.DateOnly> then Some(wrapValue reader.GetDateOnly)
        elif t = typedefof<System.DateOnly[]> then Some(wrapRef reader.GetFieldValue<System.DateOnly[]>)
        elif t = typedefof<System.TimeOnly> then Some(wrapValue reader.GetTimeOnly)
        elif t = typedefof<System.TimeOnly[]> then Some(wrapRef reader.GetFieldValue<System.TimeOnly[]>)
        elif t = typedefof<System.DateTime> then Some(wrapValue reader.GetDateTime)
        elif t = typedefof<System.DateTime[]> then Some(wrapRef reader.GetFieldValue<System.DateTime[]>)
        elif t = typedefof<System.DateTimeOffset> then Some(wrapValue reader.GetDateTime)
        elif t = typedefof<System.DateTimeOffset[]> then Some(wrapRef reader.GetFieldValue<System.DateTimeOffset[]>)
        elif t = typedefof<byte[]> then Some(wrapRef reader.GetFieldValue<byte[]>)
        elif t = typedefof<char> then Some(wrapRef reader.GetChar)
        elif t = typedefof<char[]> then Some(wrapRef reader.GetFieldValue<char[]>)
        elif t = typedefof<float> then Some(wrapRef reader.GetFloat)
        elif t = typedefof<float[]> then Some(wrapRef reader.GetFieldValue<float[]>)
        else None

    static member Read(reader: Npgsql.NpgsqlDataReader) = 
        let hydra = HydraReader(reader)
                    
        let getOrdinalAndIncrement() = 
            let ordinal = hydra.AccFieldCount
            hydra.AccFieldCount <- hydra.AccFieldCount + 1
            ordinal
            
        let buildEntityReadFn (t: System.Type) = 
            let t, isOpt, isNullable = 
                if t.IsGenericType && t.GetGenericTypeDefinition() = typedefof<Option<_>> then t.GenericTypeArguments[0], true, false
                elif t.IsGenericType && t.GetGenericTypeDefinition() = typedefof<System.Nullable<_>> then t.GenericTypeArguments[0], false, true
                else t, false, false
            
            match HydraReader.GetPrimitiveReader(t, reader, isOpt, isNullable) with
            | Some primitiveReader -> 
                let ord = getOrdinalAndIncrement()
                fun () -> primitiveReader ord
            | None ->
                let nameParts = t.FullName.Split([| '.'; '+' |])
                let schemaAndType = nameParts |> Array.skip (nameParts.Length - 2) |> fun parts -> System.String.Join(".", parts)
                hydra.GetReaderByName(schemaAndType, isOpt)
            
        // Return a fn that will hydrate 'T (which may be a tuple)
        // This fn will be called once per each record returned by the data reader.
        let t = typeof<'T>
        if FSharp.Reflection.FSharpType.IsTuple(t) then
            let readEntityFns = FSharp.Reflection.FSharpType.GetTupleElements(t) |> Array.map buildEntityReadFn
            fun () ->
                let entities = readEntityFns |> Array.map (fun read -> read())
                Microsoft.FSharp.Reflection.FSharpValue.MakeTuple(entities, t) :?> 'T
        else
            let readEntityFn = t |> buildEntityReadFn
            fun () -> 
                readEntityFn() :?> 'T
        
